<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<!--
1 内存 ，内存中的2个数据： 内部村粗的数据 地址值
      * 内存分类： 栈 全局、局部变量
                 堆 对象
2 变量 变量名和变量值 每个变量对应一个小内存  变量名用来查找对应的内存 变量值是内存中数据
3 数据
  *数据特点： 可传递 可运算
  *一切皆数据
  *内存中所有操作的目标：数据
  *算术运算 逻辑运算 赋值 运行函数
4 内存 数据 变量的关系
  *内存用来存储数据的空间
  *内存是变量名的标识
-->

<!--
关于引用变量赋值问题
  *2个引用变量指向同一个对象 通过一个变量修改对象内部数据 另一个变量看到的是修改之后的数据
问题
  在js调用函数时传递变量参数时，是值传递还是引用传递？
    *都是值 （基本/地址）传递 永远传递的是变量的值，只是这个值可能是地址值
    *可能是值传递 也可能是引用传递

-->

<!--
问题：JS引擎如何管理内存
1.内存生命周期
  * 分配小内存空间 得到使用权
  *存储数据，可以反复进行操作
  *释放小内存空间
2. 释放内存
  *局部变量： 函数执行玩自动释放
  *对象：  成为垃圾对象 垃圾回收器回收

-->

<!--
1.什么是对象
  *多个数据的封装体
  *用来保存多个数据的容器
  *一个对象代表现实中的一个事物
2.为什么要用对象
  *统一管理多个数据
3.对象的组成
  *属性： 属性名和属性值
  *方法： 方法是一种特别的属性（属性值是函数，成为方法）
4.如何访问对象内部数据
  *.属性名  有时不能用
  对象['属性名']  能通用
      1.属性名包含特殊字符
      2.变量名不确定
-->

<!--
1.什么是函数
  *实现特定功能的n条语句的封装体

2.为什么要用函数
  *提高代码复用
  *便于阅读交流
3.如何定义函数
  *函数申明function a（）{}
  *表达式 var a = function （）{}
4.如何调用（执行）函数
  *test()
  *obj.test()
  *new test()
  *test.call/apply(obj):临时让test 成为obj的方法进行调用
-->
<!--
1.什么函数才是回调函数
  *你定义的
  *你没有调用
  *但最终执行了

2.常见的回调函数
  *dom事件回调函数 this 发生事件的dom元素 比如按钮
  *定时器回调函数  this 指向window
  *ajax请求回调函数
  *生命周期回调函数

定时器： 超时定时器setTimeout 循环定时器
-->
<!--
IIFE (function)()  匿名函数自调用
1.理解
  *全称：Immediately Invoked Function expression
2.作用
  *隐藏实现
  *不会污染外部（全局）命名空间
  *用它来编码JS模块

-->
<!--
1.this是什么
  *任何函数本质上都是通过对象来调用 如果没有指定就是window
  *所有函数内部都要一个变量this
  *它的值是调用函数的当前对象
2.如何确定this的值
  *window
  *p.test（）： p
  *new test（） 新创建的对象
  *p.call（obj） obj
-->

<!--
分好问题：
1. 看个人喜好
必须加：
   *小括号开头的上一条语句
   *中方括号开头的前一条语句
-->

<!--
1.函数的prototype属性
  *每个函数都有一个prototype属性，他默认指向一个object空对象（即 原型对象）
  *原型对象中有一个属性constructor ，他指向函数对象
2.给原型对象添加属性（一般都是方法）
  *作用： 函数的所有实例对象自动拥有原型中的属性（方法）
-->

<!--
显示原型和隐式原型
1.每个函数function都有一个prototype，即显式原型
2.每个实例对象都有一个__proto__，可称为隐式原型
3.对象的隐式原型的值为其对应构造函数的显示原型的值
4.内存结构
5.总结：
  *函数的prototype属性：在定义函数时自动添加的，默认值是一个空object对象
  *对象的__proto__属性：在创建对象时自动添加到的，默认值为构造函数的prototype属性值
  *程序员能直接操作显示原型，但不能直接操作隐式原型
-->
<!--
1.原型链
  *访问一个对象的属性时
   *先在自身属性中查找，找到返回
   *如果没有再 沿着__proto__这条链向上查找，找到返回
   *如果最终没找到，返回undefined
  *别名 ：隐式原型链
  *作用：查找对象的属性
2.构造函数/原型/实体对象的关系
3.构造函数/原型、实体对象的关系

1.函数的显示原型指向的对象：默认是空object实例对象（但是Object不满足 ，它的原型对象
2. 所有函数都是Function的实例 （包含Function Function是它自身的实例）
3.Object 的原型对象是原型链的尽头
-->

<!--
1.读取对象的属性值时：会自动到原型链中查找
2.设置对象的属性值时： 不会查找原型链，如果当前对象中没有此属性，直接添加属性并设置其值
3.方法一般定义在原型中，属性一般通过构造函数定义在对象本身上
-->

<!--
1. 变量申明提升
  *通过var定义的变量 ，在定义语句之前就可以访问到
  *值：undefined
2.函数声明提升
  *通过function声明的函数，在之前就可以直接调用
  *值：函数定义（对象）
3.问题：变量提升和函数是如何产生的？
-->
<!--
1.全局执行上下文
  *在执行全局代码前将window确定为全局执行上下文
  *对全局数据进行预处理
    *var定义的全局变量==》undefined，添加window的属性
    *function声明的全局函数==》赋值，添加window的方法
    *this==》赋值（window）
   *开始执行全局代码
2.函数执行上下文
  *在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
  *对局部数据进行预处理
    *形参变量==》赋值==》添加为执行上下文的属性
    *arguments==》赋值，添加为执行上下文的属性
    *var定义的全局变量==》undefined，添加为执行上下文的属性
    *function声明的函数 ==》赋值，添加为执行上下文的属性
    *this ==》赋值（调用函数的对象）
3.先执行变量提升，再执行函数提升
-->
<!--
1作用域
  *全局作用域
  *函数作用域
  *块作用域
2.作用
  隔离变量 不同作用域下同名变量不会冲突
-->
<!--
1.如何产生闭包
  *当一个嵌套的内部（子）函数引用嵌套的外部（父）函数的变量（函数）时，就产生了闭包
2.闭包到底是什么
  *使用Chrome调试查看
  *理解一： 闭包是嵌套的内部函数（绝大部分人）
  *理解二：包含被引用变量（函数）的对象（极少数人）
  *注意：闭包存在于嵌套的内部函数中
3.产生闭包的条件
  *函数嵌套
  *内部函数引用了外部函数的数据（变量、函数）


运用1
1.将函数作为另一个函数的返回值
2.将函数作为实参传递给另一个函数调用
作用：
1.使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
2.让函数外部可以操作（读写）到函数内部的数据
  问题：
  1.函数执行完后，函数内部申明的局部变量是否还存在 一般不存在，存在于闭包中的变量还存在
  2.在函数外部能直接访问函数内部的局部变量吗 不能 但是通过闭包让外部操作

运用2:定义JS 模块
  *具有特定功能的JS文件
  *将所有的数据和功能都封装在一个函数内部（私有）
  *只向外暴露一个包含n个方法的对象或函数 多个函数封装成对象
  *模块的使用者，只需要通过模块暴露的对象的调用方法来实现对应的功能

1.缺点：
  *函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
  *容易造成内存泄露
2.解决
  *能不用闭包就不用
  *及时释放

1.内存溢出
  *一种程序运行出现的错误
  *当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误
-->

<!--
方式1.原型链继承
关键：
  子类型的显式原型为父类型的一个实例对象
方式2 借用构造函数继承（假的）
  关键 在子类型构造函数中通用call（） 调用父类型构造函数
  借用构造函数是为了得到属性
方式3 原型链+借用构造函数的组合继承
-->
<!--
web workers多线程
1.H5规范提供了js分线程的实现，取名为：web workers
2. 相关API
  *worker：构造函数，加载分线程执行的js文件
  *worker.prototype.onmessage: 用于接收另一个线程的回调函数
  *worker.prototype.postMessage：向另一个线程发送消息
3. 不足
  *worker内代码不能操作Dom（更新UI）
  *不能跨域加载JS
  *不是每个浏览器都支持这个新特性
  

-->







</body>
<script type="text/javascript" src = mymodel.js></script>
<script type="text/javascript">
// var fn = myModel()
//   fn.dootherthing()
  myModel.dosomething()

</script>
</html>